############################################
#                                          #
#   Context-Free Grammar Generator         #
#                                          #
#   by Truong Kien Tuong (@kientuong114)   #
#   April 2019                             #
#                                          #
############################################

import json
import random
from math import exp

#Set here the file from which the grammar productions are loaded
RULES_FILE = "rules.json"

#Some constants
MAX_LENGTH = 300
MIN_LENGTH = 10

DEBUG_MODE = False

#The character used to separate the various terminal characters after the string is finally generated. Can be the empty string "".
SPACING_CHAR = ""

#Loads the file
data = json.load(open(RULES_FILE))

def validateRules():
    #Analyzes the rules and tries to verify syntax errors
    for key, rules in data['rules'].items():
        for rule in rules:
            if rule['type'] == "nonfinal":
                for elem in rule['production']:
                    if type(elem) == dict:
                        assert elem['non_term'] in data['rules'], "Couldn't find "+elem['non_term']+" in the list of production. (Generated by production with left-hand side "+key+"). Check for typos in the rules"

def getRandomProduction(non_term, isFinal):
    #Looks at all the productions which have a matching left-hand side and returns the right-hand side of a randomly chosen production
    #First, it checks if a non-terminal production actually exists. If there are non-terminal productions then it will try to return one of them.
    #It will return a terminal production otherwise
    nonTermExists = False
    for key, rules in data['rules'].items():
        if non_term == key:
            for rule in rules:
                if rule['type'] == "non_final":
                    nonTermExists = True
                    break
            break
    for key, rules in data['rules'].items():
        if non_term == key:
            select = random.choice(rules)
            if nonTermExists == False:
                return select
            while select['type'] != isFinal:
                select = random.choice(rules)
            return select
    raise Exception('Left hand side not found. No such element as \"'+non_term+'\"')

def stringGenerate(stringArray):
    #Collapses the array into a string
    if len(stringArray)==0:
        return ""
    return SPACING_CHAR.join(stringArray)

def getStringLength(stringArray):
    #Returns a preliminary length for the string, assessing how close we are to reaching the MAX_LENGTH limit
    length = 0
    for item in stringArray:
        if type(item)!=dict:
            length += len(item)
    return length

def stringValidate(stringArray):
    #String is invalid if either it is not entirely composed of terminal symbols or it doesn't meet the size requirements
    #Returns string if valid, and False otherwise
    for elem in stringArray:
        if type(elem) == dict:
            return False
    string = stringGenerate(stringArray)
    if len(string) < MIN_LENGTH or len(string) > MAX_LENGTH:
        return False
    return string

def isGenerationComplete(stringArray):
    for elem in stringArray:
        if type(elem) == dict:
            return False
    return True

def isStringValid(string):
    if len(string) < MIN_LENGTH or len(string) > MAX_LENGTH:
        return False
    return True

def stringAttempt(): 
    #Generates a string by using the grammar rules, starting from the single non-terminal "S" axiom
    #Each iterations substitutes a non-terminal with the right-hand side of a production
    #At the start the probability of getting another non-terminal production is 1 and scales down following an exponential function
    stringGen = [{"non_term": "S"}]
    while isGenerationComplete(stringGen) == False:
        index = 0
        while index < len(stringGen):
            if type(stringGen[index])==dict:
                current_length = getStringLength(stringGen)
                number = random.random()
                if number < exp(-1*float(current_length)/(float(MAX_LENGTH))):
                    #Requests a non-terminal production
                    stringGen[index:index] = getRandomProduction(stringGen.pop(index)['non_term'], "nonfinal")['production']
                else:
                    #Requests a terminal production
                    stringGen[index:index] = getRandomProduction(stringGen.pop(index)['non_term'], "final")['production']
            index += 1
    return stringGenerate(stringGen)

def generate():
    #Tries to generate strings until it finds a valid one (length-wise)
    while True:
        outString = stringAttempt()
        if isStringValid(outString) == True:
            return outString

def debugGenerate():
    #Generates 10000 strings and outputs some statistics for the generated strings
    tot = 0
    currmax = 0
    for i in range(10000):
        result = str(generate())
        currmax = max(currmax, len(result))
        print(result)
        tot += len(result)
    print("Average length: ", float(tot)/10000)
    print("Max length: ", currmax)

def printInfo():
    #Preliminary informations
    print("Informations on Opened File")
    print("File Name:",data['name'])
    print("Version:",data['version'])
    print("Author:",data['author'])
    print("Rules:")
    for key, rules in data['rules'].items():
        print(key, "->")
        for production in rules:
            print(production['production'])

if __name__ == "__main__":
    validateRules()
    if DEBUG_MODE == True:
        printInfo()
        debugGenerate()
    else:
        print(generate())
